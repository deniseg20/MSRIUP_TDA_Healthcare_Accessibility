#Have to write requirement texts
requests>=2.28.0
pandas>=1.5.0
numpy>=1.21.0

#Installing some packages
pip install requests pandas numpy

#Starting the main code 
import requests
import json
import time
import pandas as pd
import numpy as np
from typing import List, Dict, Tuple
import logging
from datetime import datetime
import os

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class GoogleRoutesDistanceMatrix:
    def __init__(self, api_key: str):
        """
        Initialize the Google Routes API distance matrix generator.
        
        Args:
            api_key (str): Your Google Routes API key
        """
        self.api_key = api_key
        self.base_url = "https://routes.googleapis.com/directions/v2:computeRoutes"
        self.headers = {
            "Content-Type": "application/json",
            "X-Goog-Api-Key": api_key,
            "X-Goog-FieldMask": "routes.duration,routes.distanceMeters,routes.polyline.encodedPolyline"
        }
        
        # ============================================================================
        # TRANSPORTATION MODES CONFIGURATION
        # ============================================================================
        # Define the three transportation modes supported by Google Routes API
        self.transport_modes = {
            "driving": "DRIVE",        # Car/vehicle transportation
            "walking": "WALK",         # Pedestrian transportation  
            "public_transport": "TRANSIT"  # Public transportation (bus, train, etc.)
        }
        
        # ============================================================================
        # RESULTS STORAGE FOR EACH TRANSPORTATION MODE
        # ============================================================================
        # Separate storage for results from each transportation mode
        self.results = {
            "driving": {},           # Store driving route results
            "walking": {},           # Store walking route results
            "public_transport": {}   # Store public transport route results
        }
    
    def get_nearest_neighbors(self, locations: List[Dict], target_index: int, n_neighbors: int = 20) -> List[int]:
        """
        Find the n nearest neighbors for a given location using Euclidean distance.
        
        Args:
            locations (List[Dict]): List of location dictionaries with 'lat' and 'lng' keys
            target_index (int): Index of the target location
            n_neighbors (int): Number of nearest neighbors to find
            
        Returns:
            List[int]: List of indices of the nearest neighbors
        """
        target = locations[target_index]
        target_coords = np.array([target['lat'], target['lng']])
        
        distances = []
        for i, location in enumerate(locations):
            if i != target_index:
                coords = np.array([location['lat'], location['lng']])
                distance = np.linalg.norm(target_coords - coords)
                distances.append((i, distance))
        
        # Sort by distance and get top n_neighbors
        distances.sort(key=lambda x: x[1])
        return [idx for idx, _ in distances[:n_neighbors]]
    
    def create_route_request(self, origin: Dict, destination: Dict, transport_mode: str) -> Dict:
        """
        Create a route request payload for the Google Routes API.
        
        Args:
            origin (Dict): Origin location with 'lat' and 'lng' keys
            destination (Dict): Destination location with 'lat' and 'lng' keys
            transport_mode (str): Transportation mode ('driving', 'walking', 'public_transport')
            
        Returns:
            Dict: API request payload
        """
        # ============================================================================
        # BASE REQUEST STRUCTURE (COMMON FOR ALL TRANSPORTATION MODES)
        # ============================================================================
        request = {
            "origin": {
                "location": {
                    "latLng": {
                        "latitude": origin['lat'],
                        "longitude": origin['lng']
                    }
                }
            },
            "destination": {
                "location": {
                    "latLng": {
                        "latitude": destination['lat'],
                        "longitude": destination['lng']
                    }
                }
            },
            "travelMode": self.transport_modes[transport_mode],
            "computeAlternativeRoutes": False,
            "languageCode": "en-US",
            "units": "METRIC"
        }
        
        # ============================================================================
        # TRANSPORTATION MODE SPECIFIC CONFIGURATIONS
        # ============================================================================
        
        # ============================================================================
        # DRIVING MODE CONFIGURATION
        # ============================================================================
        if transport_mode == "driving":
            request["routingPreference"] = "TRAFFIC_UNAWARE"  # No real-time traffic data
            request["routeModifiers"] = {
                "avoidTolls": False,      # Allow toll roads
                "avoidHighways": False    # Allow highways
            }
        
        # ============================================================================
        # WALKING MODE CONFIGURATION  
        # ============================================================================
        elif transport_mode == "walking":
            request["routingPreference"] = "DEFAULT"  # Standard walking routing
            # No additional modifiers needed for walking
        
        # ============================================================================
        # PUBLIC TRANSPORT MODE CONFIGURATION
        # ============================================================================
        elif transport_mode == "public_transport":
            request["routingPreference"] = "DEFAULT"  # Standard transit routing
            request["transitPreferences"] = {
                "allowedTravelModes": ["BUS", "SUBWAY", "TRAIN", "TRAM"],  # All public transport types
                "routingPreference": "FEWER_TRANSFERS"  # Prefer routes with fewer transfers
            }
        
        return request
    
    def get_route_duration(self, origin: Dict, destination: Dict, transport_mode: str) -> Tuple[int, int]:
        """
        Get route duration and distance between two locations.
        
        Args:
            origin (Dict): Origin location with 'lat' and 'lng' keys
            destination (Dict): Destination location with 'lat' and 'lng' keys
            transport_mode (str): Transportation mode
            
        Returns:
            Tuple[int, int]: (duration_seconds, distance_meters) or (None, None) if error
        """
        try:
            request_payload = self.create_route_request(origin, destination, transport_mode)
            
            response = requests.post(
                self.base_url,
                headers=self.headers,
                json=request_payload,
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'routes' in data and len(data['routes']) > 0:
                    route = data['routes'][0]
                    duration = route.get('duration', '0s')
                    distance = route.get('distanceMeters', 0)
                    
                    # Convert duration string to seconds
                    if isinstance(duration, str):
                        duration_seconds = self.parse_duration(duration)
                    else:
                        duration_seconds = int(duration)
                    
                    return duration_seconds, distance
                else:
                    logger.warning(f"No route found for {transport_mode} from {origin} to {destination}")
                    return None, None
            else:
                logger.error(f"API request failed: {response.status_code} - {response.text}")
                return None, None
                
        except Exception as e:
            logger.error(f"Error getting route for {transport_mode}: {str(e)}")
            return None, None
    
    def parse_duration(self, duration_str: str) -> int:
        """
        Parse duration string from Google API (e.g., "3600s") to seconds.
        
        Args:
            duration_str (str): Duration string from API
            
        Returns:
            int: Duration in seconds
        """
        try:
            if duration_str.endswith('s'):
                return int(duration_str[:-1])
            return int(duration_str)
        except:
            return 0
    
    def generate_distance_matrix(self, locations: List[Dict], n_neighbors: int = 20) -> Dict:
        """
        Generate distance matrix for all locations, focusing on nearest neighbors.
        
        Args:
            locations (List[Dict]): List of location dictionaries with 'lat' and 'lng' keys
            n_neighbors (int): Number of nearest neighbors to calculate for each location
            
        Returns:
            Dict: Complete distance matrix results
        """
        total_locations = len(locations)
        logger.info(f"Starting distance matrix generation for {total_locations} locations")
        
        for i, origin in enumerate(locations):
            logger.info(f"Processing location {i+1}/{total_locations}: {origin.get('name', f'Location {i}')}")
            
            # Get nearest neighbors for this location
            neighbor_indices = self.get_nearest_neighbors(locations, i, n_neighbors)
            
            # ============================================================================
            # INITIALIZE RESULTS STORAGE FOR ALL TRANSPORTATION MODES
            # ============================================================================
            for mode in self.transport_modes.keys():
                if i not in self.results[mode]:
                    self.results[mode][i] = {}
            
            # ============================================================================
            # CALCULATE OUTBOUND ROUTES TO NEAREST NEIGHBORS
            # ============================================================================
            # Calculate routes to each neighbor for all transportation modes
            for neighbor_idx in neighbor_indices:
                destination = locations[neighbor_idx]
                
                # ============================================================================
                # PROCESS EACH TRANSPORTATION MODE FOR OUTBOUND ROUTES
                # ============================================================================
                for transport_mode in self.transport_modes.keys():
                    duration, distance = self.get_route_duration(origin, destination, transport_mode)
                    
                    if duration is not None:
                        self.results[transport_mode][i][neighbor_idx] = {
                            'duration_seconds': duration,
                            'duration_minutes': round(duration / 60, 2),
                            'distance_meters': distance,
                            'distance_km': round(distance / 1000, 2)
                        }
                    
                    # Rate limiting to avoid API quota issues
                    time.sleep(0.1)
            
            # ============================================================================
            # CALCULATE RETURN ROUTES (FROM NEIGHBOR BACK TO ORIGIN)
            # ============================================================================
            # Calculate return routes from each neighbor back to the origin
            for neighbor_idx in neighbor_indices:
                origin_neighbor = locations[neighbor_idx]
                
                # ============================================================================
                # PROCESS EACH TRANSPORTATION MODE FOR RETURN ROUTES
                # ============================================================================
                for transport_mode in self.transport_modes.keys():
                    duration, distance = self.get_route_duration(origin_neighbor, origin, transport_mode)
                    
                    if duration is not None:
                        # Store return route with special key to distinguish from outbound
                        return_key = f"return_{i}"
                        if return_key not in self.results[transport_mode][neighbor_idx]:
                            self.results[transport_mode][neighbor_idx][return_key] = {}
                        
                        self.results[transport_mode][neighbor_idx][return_key][i] = {
                            'duration_seconds': duration,
                            'duration_minutes': round(duration / 60, 2),
                            'distance_meters': distance,
                            'distance_km': round(distance / 1000, 2)
                        }
                    
                    # Rate limiting
                    time.sleep(0.1)
            
            # Progress update
            if (i + 1) % 10 == 0:
                logger.info(f"Completed {i+1}/{total_locations} locations")
        
        return self.results
    
    def save_results_to_csv(self, locations: List[Dict], output_dir: str = "results"):
        """
        Save results to CSV files for each transportation mode.
        
        Args:
            locations (List[Dict]): List of location dictionaries
            output_dir (str): Directory to save CSV files
        """
        os.makedirs(output_dir, exist_ok=True)
        
        # ============================================================================
        # SAVE RESULTS FOR EACH TRANSPORTATION MODE TO SEPARATE CSV FILES
        # ============================================================================
        for transport_mode in self.transport_modes.keys():
            logger.info(f"Saving {transport_mode} results to CSV...")
            
            # Prepare data for CSV
            rows = []
            for origin_idx, destinations in self.results[transport_mode].items():
                origin_name = locations[origin_idx].get('name', f'Location_{origin_idx}')
                
                for dest_idx, route_data in destinations.items():
                    if isinstance(dest_idx, str) and dest_idx.startswith('return_'):
                        # This is a return route
                        actual_dest_idx = int(dest_idx.split('_')[1])
                        dest_name = locations[actual_dest_idx].get('name', f'Location_{actual_dest_idx}')
                        direction = 'return'
                    else:
                        dest_name = locations[dest_idx].get('name', f'Location_{dest_idx}')
                        direction = 'outbound'
                    
                    rows.append({
                        'origin_index': origin_idx,
                        'origin_name': origin_name,
                        'destination_index': dest_idx if not isinstance(dest_idx, str) else actual_dest_idx,
                        'destination_name': dest_name,
                        'direction': direction,
                        'transport_mode': transport_mode,
                        'duration_seconds': route_data['duration_seconds'],
                        'duration_minutes': route_data['duration_minutes'],
                        'distance_meters': route_data['distance_meters'],
                        'distance_km': route_data['distance_km']
                    })
            
            # Create DataFrame and save to CSV
            df = pd.DataFrame(rows)
            filename = f"{output_dir}/{transport_mode}_distance_matrix.csv"
            df.to_csv(filename, index=False)
            logger.info(f"Saved {transport_mode} results to {filename}")
    
    def save_results_to_json(self, output_dir: str = "results"):
        """
        Save complete results to JSON file.
        
        Args:
            output_dir (str): Directory to save JSON file
        """
        os.makedirs(output_dir, exist_ok=True)
        
        filename = f"{output_dir}/complete_distance_matrix.json"
        with open(filename, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        logger.info(f"Saved complete results to {filename}")


def load_locations_from_csv(csv_file: str) -> List[Dict]:
    """
    Load locations from a CSV file.
    
    Expected CSV format:
    name,lat,lng
    Location 1,40.7128,-74.0060
    Location 2,34.0522,-118.2437
    ...
    
    Args:
        csv_file (str): Path to CSV file
        
    Returns:
        List[Dict]: List of location dictionaries
    """
    df = pd.read_csv(csv_file)
    locations = []
    
    for _, row in df.iterrows():
        locations.append({
            'name': row['name'],
            'lat': float(row['lat']),
            'lng': float(row['lng'])
        })
    
    return locations


def create_sample_locations_csv(filename: str = "sample_locations.csv", num_locations: int = 411):
    """
    Create a sample CSV file with random locations for testing.
    
    Args:
        filename (str): Output CSV filename
        num_locations (int): Number of locations to generate
    """
    # Generate random locations around major cities
    cities = [
        (40.7128, -74.0060, "New York"),
        (34.0522, -118.2437, "Los Angeles"),
        (41.8781, -87.6298, "Chicago"),
        (29.7604, -95.3698, "Houston"),
        (39.9526, -75.1652, "Philadelphia")
    ]
    
    locations = []
    for i in range(num_locations):
        # Pick a random city as base
        base_lat, base_lng, city_name = cities[i % len(cities)]
        
        # Add some random variation
        lat = base_lat + np.random.uniform(-0.1, 0.1)
        lng = base_lng + np.random.uniform(-0.1, 0.1)
        
        locations.append({
            'name': f"{city_name} Location {i+1}",
            'lat': lat,
            'lng': lng
        })
    
    df = pd.DataFrame(locations)
    df.to_csv(filename, index=False)
    logger.info(f"Created sample locations file: {filename}")


def main():
    """
    Main function to run the distance matrix generation.
    """
    # Configuration
    API_KEY = "YOUR_GOOGLE_ROUTES_API_KEY_HERE"  # Replace with your actual API key
    LOCATIONS_FILE = "locations.csv"  # Your locations CSV file
    N_NEIGHBORS = 20
    OUTPUT_DIR = "results"
    
    # Check if API key is set
    if API_KEY == "YOUR_GOOGLE_ROUTES_API_KEY_HERE":
        logger.error("Please set your Google Routes API key in the script!")
        return
    
    # Create sample locations file if it doesn't exist
    if not os.path.exists(LOCATIONS_FILE):
        logger.info("Creating sample locations file...")
        create_sample_locations_csv(LOCATIONS_FILE, 411)
    
    # Load locations
    logger.info(f"Loading locations from {LOCATIONS_FILE}...")
    locations = load_locations_from_csv(LOCATIONS_FILE)
    logger.info(f"Loaded {len(locations)} locations")
    
    # Initialize distance matrix generator
    matrix_generator = GoogleRoutesDistanceMatrix(API_KEY)
    
    # Generate distance matrix
    logger.info("Starting distance matrix generation...")
    start_time = datetime.now()
    
    results = matrix_generator.generate_distance_matrix(locations, N_NEIGHBORS)
    
    end_time = datetime.now()
    duration = end_time - start_time
    logger.info(f"Distance matrix generation completed in {duration}")
    
    # Save results
    logger.info("Saving results...")
    matrix_generator.save_results_to_csv(locations, OUTPUT_DIR)
    matrix_generator.save_results_to_json(OUTPUT_DIR)
    
    logger.info("All done! Check the 'results' directory for output files.")


if __name__ == "__main__":
    main()
